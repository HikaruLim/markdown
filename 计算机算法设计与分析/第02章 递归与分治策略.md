# 递归与分治策略

## 1.递归

* n! 的递归算法

```c++
int factorial(int n) {
    return n != 0 ? (n * factorial(n - 1)) : 1;
}
```

* 斐波那契(Fiboncci)数列

```c++
int Fib(int n) {
    return n < 2 ? 1 : (fibonacci(n-1)+fibonacci(n-2));
}
```

* Ackerman函数（双递归函数)

* 汉诺塔

```c++
void hanoi(int n, int a, int b, int c) {
    if(n > 0) {
        hanoi(n - 1, a, c, b);
        move(a, b);
        hanoi(n - 1, c, b, a);
    }
}
```

## 2.分治

* **【 二分搜索技术 】** - 时间复杂度:*O(logn)*

```c++
//前提是有序数组
template<clss Type> //Type数组的数据类型,n代表数组大小
int BinarySearch(Type a[], const Type& x, int n) {
    //找到X时返回其在数组中的位置，否则返回-1
    int left = 0;
    int right = n - 1;
    while(left <= right) {
        int middle = (left + right) / 2;
        if(x == a[middle])
            return middle;  //找到返回下标
        if(x > a[middle])   //当前数据比中间数据大
            left = middle + 1;  //左界限向右移动一位
        else
            right = middle - 1; //反之，右界限左移一位
    }
    return -1;
}
```

* 大整数乘法

* Strassen矩阵乘法

* 棋盘覆盖 - 时间复杂度：*O(4^n)*

```c++
int tile = 0;
int Board[2^k][2^k];
void ChessBoard(int tr, int tc, int dr, int dc, int size) {
    if(size == 1)
        return;
    int t = tilr++, s = size/2;
    if(dr < tr+s && dc < tc+s)
        ChessBoard(tr, tc, dr, dc, s);
    else{
        Board[tr+s-1][tc+s-1] = t;
        ChessBoard(tr, tc, tr+s-1, tc+s-1, s);
    }
    if(dr < tr+s && dc < tc+s)
        ChessBoard(tr, tc+s, dr, dc, s);
    else{
        Board[tr+s-1][tc+s] = t;
        ChessBoard(tr, tc+s, tr+s-1, tc+s, s);
    }
    if(dr >= tr+s && dc < tc+s)
        ChessBoard(tr+s, tc, dr, dc, s);
    else{
        Board[tr+s][tc+s-1] = t;
        ChessBoard(tr+s, tc, tr+s, tc+s-1, s);
    }
    if(dr >= tr+s && dc < tc+s)
        ChessBoard(tr+s, tc+s, dr, dc, s);
    else{
        Board[tr+s][tc+s] = t;
        ChessBoard(tr+s, tc+s, tr+s, tc+s, s);
    }
}
```
